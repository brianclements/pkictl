#!/bin/bash
##----------------
##Name: pkictl
##Description: A biased controller script to aid in common openssl management
##             tasks
##Date: 2015.01.20-12:46 
##Version: 0.8.0-beta
##Requirements: openssl
##----------------

# CA settings
export PKICTL_ORG=${PKICTL_ORG:-"myorg.local"}  # Same as organizationName used in *.conf files

# Script settings
export PKICTL_CONFIG_DIR=${PKICTL_CONFIG_DIR:-$PWD}
export PKICTL_CA_DIR=${PKICTL_CA_DIR:-$PWD}
export PKICTL_SSL_DIR=${PKICTL_SSL_DIR:-/etc/ssl}
export PKICTL_CLIENTCERTS_DIR=${PKICTL_CLIENTCERTS_DIR:-/etc/ssl/certs}
export PKICTL_IMPORT_DIR=${PKICTL_IMPORT_DIR:-$PWD}

# OS settings
export PKICTL_UPDATE_CERTS_CMD=$(command -v update-ca-certificates)

# Depending on location and distro, certs need "pem" or "crt" suffix to be
# recognized by update-ca-certificates
case "$PKICTL_CLIENTCERTS_DIR" in
    /etc/ssl/certs)
        declare CERT_EXT="pem"
        ;;
    *)
        declare CERT_EXT="crt"
        ;;
esac

##############################################################################
## Setup
##############################################################################

init_ca_folders() {
    if [[ -d "$caPath" ]]; then
        echo "Cannot init new CA with existing filename. Aborting."
        exit 1
    fi
    mkdir -p "${caPath}/private" "${caPath}/db" "${caPath}/crl" "${caPath}/certs"
    chmod 700 "${caPath}/private"
}

init_ca_db() {
    cp /dev/null "${caPath}/db/${caName}.db"
    cp /dev/null "${caPath}/db/${caName}.db.attr"
    echo 01 > "${caPath}/db/${caName}.crt.srl"
    echo 01 > "${caPath}/db/${caName}.crl.srl"
}

init_import_folders() {
    if [[ ! -d "$sslClientPath" ]]; then
        mkdir -p "${sslClientPath}/private" "${sslClientPath}/certs" "${sslClientPath}/tmp"
        chmod 770 "${sslClientPath}/private"
    fi
}

##############################################################################
## Openssl commands
##############################################################################

gen_request() {
    declare csrName=${eeName:-"$caName"}
    openssl req -new \
        -config "$conf" \
        -out "${caPath}/${csrName}.csr" \
        -keyout "${caPath}/private/${csrName}.key"
    chmod 700 "${caPath}/private/${csrName}.key"
}

sign_root_ca_request() {
    declare csrName="$caName"
    declare outName="$caName"
    if [[ "$PKICTL_CA_EXTENSIONS" == "" ]] && [[ "$PKICTL_CA_POLICY" == "" ]]; then
        openssl ca -selfsign \
            -config "$conf" \
            -in "${caPath}/${csrName}.csr" \
            -out "${caPath}/${outName}.crt"
    elif [[ "$PKICTL_CA_EXTENSIONS" != "" ]] && [[ "$PKICTL_CA_POLICY" == "" ]]; then
        openssl ca -selfsign \
            -config "$conf" \
            -in "${caPath}/${csrName}.csr" \
            -out "${caPath}/${outName}.crt" \
            -extensions "$PKICTL_CA_EXTENSIONS"
    elif [[ "$PKICTL_CA_EXTENSIONS" == "" ]] && [[ "$PKICTL_CA_POLICY" != "" ]]; then
        openssl ca -selfsign \
            -config "$conf" \
            -in "${caPath}/${csrName}.csr" \
            -out "${caPath}/${outName}.crt" \
            -policy "$PKICTL_CA_POLICY"
    else
        openssl ca -selfsign \
            -config "$conf" \
            -in "${caPath}/${csrName}.csr" \
            -out "${caPath}/${outName}.crt" \
            -policy "$PKICTL_CA_POLICY" \
            -extensions "$PKICTL_CA_EXTENSIONS"
    fi

    if [[ "$?" -eq 0 ]]; then
        rm "${caPath}/${csrName}.csr"
    fi
}

sign_request() {
    declare csrName=${csrName:-"$caName"}
    declare outName=${csrName:-"$caName"}
    if [[ "$PKICTL_CA_EXTENSIONS" == "" ]] && [[ "$PKICTL_CA_POLICY" == "" ]]; then
        openssl ca \
            -config "$conf" \
            -in "${caPath}/${csrName}.csr" \
            -out "${caPath}/${outName}.crt"
    elif [[ "$PKICTL_CA_EXTENSIONS" != "" ]] && [[ "$PKICTL_CA_POLICY" == "" ]]; then
        openssl ca \
            -config "$conf" \
            -in "${caPath}/${csrName}.csr" \
            -out "${caPath}/${outName}.crt" \
            -extensions "$PKICTL_CA_EXTENSIONS"
    elif [[ "$PKICTL_CA_EXTENSIONS" == "" ]] && [[ "$PKICTL_CA_POLICY" != "" ]]; then
        openssl ca \
            -config "$conf" \
            -in "${caPath}/${csrName}.csr" \
            -out "${caPath}/${outName}.crt" \
            -policy "$PKICTL_CA_POLICY"
    else
        openssl ca \
            -config "$conf" \
            -in "${caPath}/${csrName}.csr" \
            -out "${caPath}/${outName}.crt" \
            -policy "$PKICTL_CA_POLICY" \
            -extensions "$PKICTL_CA_EXTENSIONS"
    fi

    if [[ "$?" -eq 0 ]]; then
        rm "${caPath}/${csrName}.csr"
    fi
}

gen_crl() {
    openssl ca -gencrl \
        -config "$conf" \
        -out "${caPath}/crl/${caName}.crl"
}

gen_pem() {
    cat "${subCert}" "${parentCert}" > \
        "${caPath}/${PKICTL_ORG}-${subCaLabel}.chain.pem"
}

gen_pkcs12() {
    openssl pkcs12 -export \
        -name "${outputLabel}" \
        -inkey "${caPath}/private/${csrName}.key" \
        -in "${caPath}/${csrName}.crt" \
        -certfile "${caPath}/${PKICTL_ORG}-${signingCaLabel}.chain.pem" \
        -out "${caPath}/${exportName}.p12"
}

revoke_cert() {
    declare PKICTL_CRL_REASON=${PKICTL_CRL_REASON:-"unspecified"}
    declare revokeName=${csrName:-"$caName"}
    openssl ca \
        -config "$conf" \
        -revoke "${caPath}/${revokeName}.crt" \
        -crl_reason "$PKICTL_CRL_REASON"
}

##############################################################################
## Import Commands
##############################################################################

extract_full_chain() {
    openssl pkcs12 \
        -in "${PKICTL_IMPORT_DIR}/${PKICTL_ORG}-${exportName}.ee.p12" \
        -out "${sslClientPath}/${PKICTL_ORG}-${exportName}.chain.pem" \
        -nodes \
        -nokeys \
        -passin pass:"${PKICTL_PKCS12_PASS}"
}

extract_client_key() {
    openssl pkcs12 \
        -in "${PKICTL_IMPORT_DIR}/${PKICTL_ORG}-${exportName}.ee.p12" \
        -out "${sslClientPath}/tmp/${PKICTL_ORG}-${exportName}.ee.crt" \
        -nodes \
        -clcerts \
        -nokeys \
        -passin pass:"${PKICTL_PKCS12_PASS}"

    declare privatePath="${sslClientPath}/private"
    declare exportKey="${PKICTL_ORG}-${exportName}.ee.key"

    openssl pkcs12 \
        -in "${PKICTL_IMPORT_DIR}/${PKICTL_ORG}-${exportName}.ee.p12" \
        -out "${privatePath}/${exportKey}" \
        -nodes \
        -nocerts \
        -passin pass:"${PKICTL_PKCS12_PASS}"

    declare newName=$(openssl x509 -in "${sslClientPath}/tmp/${PKICTL_ORG}-${exportName}.ee.crt" -noout -subject | awk -F 'CN=' '{print $2}' | awk -F '/' '{print $1}')
    mv "${privatePath}/${exportKey}" "${privatePath}/${newName}.key"
    chmod 770 "${privatePath}/${newName}.key"
    rm "${sslClientPath}/tmp/${PKICTL_ORG}-${exportName}.ee.crt"
}

extract_intermediate_chain() {
    openssl pkcs12 \
        -in "${PKICTL_IMPORT_DIR}/${PKICTL_ORG}-${exportName}.ee.p12" \
        -out "${sslClientPath}/${PKICTL_ORG}-${exportName}.intermediates.pem" \
        -nodes \
        -cacerts \
        -nokeys \
        -passin pass:"${PKICTL_PKCS12_PASS}"
}

split_pem() {
    cd "${sslClientPath}/tmp"
    cat "${sslClientPath}/${PKICTL_ORG}-${exportName}.chain.pem" \
        | awk \
            'split_after==1{n++;split_after=0}\
            /-----END CERTIFICATE-----/\
            {split_after=1}\
            {print > "cert" n ".crt"}'
    for cert in *; do
        [[ -e "$cert" ]] || continue
        declare newName=$(openssl x509 -in "$cert" -noout -subject | awk -F 'CN=' '{print $2}' | awk -F '/' '{print $1}')
        mv "$cert" "${sslClientPath}/certs/${newName}.${CERT_EXT}"
    done
}

install_certs() {
    if [[ -d "${PKICTL_CLIENTCERTS_DIR}" ]]; then
        for cert in "${sslClientPath}/certs/"*; do
            [[ -e "$cert" ]] || continue
            sudo ln -sf "$cert" "${PKICTL_CLIENTCERTS_DIR}"
        done

        sudo $PKICTL_UPDATE_CERTS_CMD
    else 
        echo "error: $PKICTL_CLIENTCERTS_DIR not found. This directory should already exist and be expected by the 'update-ca-certificates' command."
        exit 1
    fi
}

##############################################################################
## CLI Commands
##############################################################################

rootca() {
    declare action="$1"
    declare caCertDepth="root"
    declare caName="${PKICTL_ORG}-${caCertDepth}.ca"
    declare caPath="${PKICTL_CA_DIR}/${caName}"
    declare conf="${PKICTL_CONFIG_DIR}/${caName}.conf"

    case "$action" in
        init)
            init_ca_folders 
            init_ca_db 
            ;;
        request)
            gen_request 
            ;;
        sign)
            declare PKICTL_CA_POLICY=${PKICTL_CA_POLICY:-""}
            declare PKICTL_CA_EXTENSIONS=${PKICTL_CA_EXTENSIONS:-"root_ca_ext"}
            sign_root_ca_request 
            ;;
        gencrl)
            gen_crl 
            ;;
        help)
            display_usage_rootca
            ;;
        *)
            echo "argument error: missing or incorrect action."
            echo ""
            display_usage_rootca
            ;;
    esac
}

subca() {
    declare action="$1"
    declare subCaLabel="$2"
    declare signingCaLabel="$3"
    if [[ "$subCaLabel" == "" ]]; then
        echo "argument error: <subca label> field required."
        echo ""
        display_usage_subca
    fi
    declare caName="${PKICTL_ORG}-${subCaLabel}.root.ca"
    declare caPath="${PKICTL_CA_DIR}/${caName}"
    declare conf="${PKICTL_CONFIG_DIR}/${caName}.conf"

    case "$action" in
        init)
            init_ca_folders 
            init_ca_db 
            ;;
        request)
            gen_request 
            ;;
        sign)
            if [[ "$signingCaLabel" == "" ]]; then
                echo "argument error: <signing CA label> field required."
                echo ""
                display_usage_subca
            elif [[ "$signingCaLabel" == "root" ]]; then
                declare conf="${PKICTL_CONFIG_DIR}/${PKICTL_ORG}-root.ca.conf"
            else
                declare conf="${PKICTL_CONFIG_DIR}/${PKICTL_ORG}-${signingCaLabel}.root.ca.conf"
            fi
            declare PKICTL_CA_POLICY=${PKICTL_CA_POLICY:-""}
            declare PKICTL_CA_EXTENSIONS=${PKICTL_CA_EXTENSIONS:-""}
            sign_request 
            ;;
        gencrl)
            gen_crl 
            ;;
        genpem)
            if [[ "$signingCaLabel" == "" ]]; then
                echo "argument error: <signing CA label> field required."
                echo ""
                display_usage_subca
            elif [[ "$signingCaLabel" == "root" ]]; then
                declare caName="${PKICTL_ORG}-root.ca"
                declare parentCert="${PKICTL_CA_DIR}/${caName}/${caName}.crt"
            else
                declare caName="${PKICTL_ORG}-${signingCaLabel}"
                declare parentCert="${PKICTL_CA_DIR}/${caName}.root.ca/${caName}.chain.pem"
            fi
            declare subCert="${caPath}/${PKICTL_ORG}-${subCaLabel}.root.ca.crt"
            gen_pem
            ;;
        revoke)
            if [[ "$signingCaLabel" == "" ]]; then
                echo "argument error: <signing CA label> field required."
                echo ""
                display_usage_subca
            elif [[ "$signingCaLabel" == "root" ]]; then
                declare conf="${PKICTL_CONFIG_DIR}/${PKICTL_ORG}-${signingCaLabel}.ca.conf"
            else
                declare conf="${PKICTL_CONFIG_DIR}/${PKICTL_ORG}-${signingCaLabel}.root.ca.conf"
            fi
            revoke_cert
            if [[ "$signingCaLabel" == "root" ]]; then
                declare caName="${PKICTL_ORG}-${signingCaLabel}.ca"
            else
                declare caName="${PKICTL_ORG}-${signingCaLabel}.root.ca"
            fi
            declare caPath="${PKICTL_CA_DIR}/${caName}"
            echo "Regenerating CRL..."
            gen_crl 
            ;;
        help)
            display_usage_subca
            ;;
        *)
            echo "argument error: missing or incorrect action."
            echo ""
            display_usage_subca
            ;;
    esac
}

eecert() {
    declare action="$1"
    declare requestLabel="$2"
    declare signingCaLabel="$3"
    declare outputLabel=${4:-$requestLabel}

    eecert_arg_check() {
        if [[ "$requestLabel" == "" ]] || [[ "$outputLabel" == "" ]]; then
            echo "argument error: <request label>, <signing CA label>, and <output label> fields required."
            echo ""
            display_usage_eecert
        fi
    }

    declare csrName="${PKICTL_ORG}-${requestLabel}.root.ee"
    declare eeName="${PKICTL_ORG}-${outputLabel}.root.ee"
    declare exportName="${PKICTL_ORG}-${outputLabel}.ee"
    declare caPath="${PKICTL_CA_DIR}/${PKICTL_ORG}-${signingCaLabel}.root.ca"

    case "$action" in
        request)
            eecert_arg_check
            declare conf="${PKICTL_CONFIG_DIR}/${PKICTL_ORG}-${requestLabel}.root.ee.conf"
            gen_request 
            ;;
        sign)
            eecert_arg_check
            declare conf="${PKICTL_CONFIG_DIR}/${PKICTL_ORG}-${signingCaLabel}.root.ca.conf"
            declare PKICTL_CA_POLICY=${PKICTL_CA_POLICY:-""}
            declare PKICTL_CA_EXTENSIONS=${PKICTL_CA_EXTENSIONS:-""}
            sign_request 
            ;;
        genpkcs12)
            eecert_arg_check
            declare caName="${PKICTL_ORG}-${signingCaLabel}.root.ca"
            gen_pkcs12
            ;;
        revoke)
            eecert_arg_check
            declare conf="${PKICTL_CONFIG_DIR}/${PKICTL_ORG}-${signingCaLabel}.root.ca.conf"
            revoke_cert
            declare caName="${PKICTL_ORG}-${signingCaLabel}.root.ca"
            declare caPath="${PKICTL_CA_DIR}/${caName}"
            echo "Regenerating CRL..."
            gen_crl 
            ;;
        import)
            declare sslClientPath="${PKICTL_SSL_DIR}/${PKICTL_ORG}"
            declare exportName="${requestLabel}"
            init_import_folders
            extract_full_chain
            extract_client_key
            extract_intermediate_chain
            split_pem
            install_certs
            rmdir "${sslClientPath}/tmp"
            ;;
        help)
            display_usage_eecert
            ;;
        *)
            echo "argument error: missing or incorrect action."
            echo ""
            display_usage_eecert
            ;;
    esac
}

##############################################################################
## Usage Info
##############################################################################

display_usage_main() {
    cat <<EOF
Usage: pkictl <subcommand> <action> <action args>

Pkictl is a biased Public Key Infrastructure (PKI) management helper tool.
It's designed to make certificate, key creation, and management tasks formal,
easy to initiate, and easy to automate. The complexities of the openssl
settings are to be absorbed by the various openssl.conf files, saving only
execution of the tasks for the script itself.

Subcommands:    Actions:
    rootca
                (init|request|sign|gencrl|help)

    subca
                (init|request|sign|gencrl|genpem|revoke|help)
                <subca label>
                [<signing CA label>]

    eecert
                (request|sign|genpkcs12|revoke|import|help)
                (<request label>|<end entity label>|<export name>)
                <signing CA label>
                [<output label>|<export name>]

    help
EOF
    exit 1
}

display_usage_rootca() {
    cat <<EOF
Usage: pkictl rootca <action>

Create a root private key, CSR, and self sign to make a root CA.

actions:
    init
            Create folder structure.

    request
            Create private key and certificate request.

    sign
            Self sign root CSR with root private key.

    gencrl
            Generate initial CRL file.
EOF
    exit 1
}

display_usage_subca() {
    cat <<EOF
Usage: pkictl subca <action> <subca label> [<signing CA label>]

Create a subordinate private key, CSR, certificate, and CRL named <subca label>
and sign it with senior CA named <signing CA label>. Optionally, revoke issued
certificate <subca label> via <signing CA label>.

Labeling Arguments:
<subca label> must be supplied on every action usage. It is made up of the
sub-levels from root and must coincide with the filename of its configuration
file. So if \$PKICTL_ORG was "sample.org", the root CA is named
"sample.org-root.ca". A subordinate CA below this one could have the name
"sub". It would be named "sample.org-sub.root.ca". In this example, the <subca
label> is "sub" while the <signing CA label> would be "root". A third level
below that could be named "tls.sub". Its full name would be
"sample.org-tls.sub.root.ca" and the <subca label> for it would be "tls.sub".

actions:
    init <subca label>
            Create folder structure.

    request <subca label>
            Create private key and certificate request.

    sign <subca label> <signing CA label>
            Sign <subca label> CSR with private key from <signing CA label> CA.

    gencrl <subca label>
            Generate initial CRL file.

    genpem <subca label> <signing CA label>
            Concatenate senior CA <signing CA label> certificate or certificate
            chain with newly generated <subca label> certificate.

    revoke <subca label> <signing CA label>
            Revoke issued certificate <subca label> with CA <signing CA label>
            and automatically generate new CRL for CA <signing CA label>
EOF
    exit 1
}

display_usage_eecert() {
    cat <<EOF
Usage: pkictl eecert <action> 
                              (<request label>|<end entity label>|<export name>)
                              <signing CA label>
                              [<output label>|<export name>]

Create an end entity CSR, private key, certificate, and PKCS#12 bundle named
<output label>, using configuration from <request label>, and sign with
subordinate CA named <signing CA label>. Later, reference <end entity label> to
choose what credentials to sign and package. Optionally, revoke issued end
entity certificate <output label> with CA named <signing CA label> or import
PKCS#12 bundle named <export name>.

Labeling Arguments:
<request label> and <signing CA label> must be supplied on every action usage.
The labeling names are made up of the sub-levels from root and must coincide
with the filename of its configuration file. So if \$PKICTL_ORG was
"sample.org", the root CA is named "sample.org-root.ca". A subordinate signing
CA two levels below could be "tls.sub", its name would be
"sample.org-tls.sub.root.ca" and its label would be "tls.sub". An end entity
certificate request could be named "node.tls.sub".  Its full name would be
"sample.org-node.tls.sub.root.ee". Notice that for end entity certificate
requests, we change the suffix to "ee" from "ca".  This is to label each as
"end entity" or "certificate authority" respectively.  To sign this
configuration, we use "node.tls.sub" as our <request label> and "tls.sub" as
our <signing CA label>.

actions:
    request <request label> <signing CA label> <output label>
            Create private key and certificate request from configuration named
            <request label> and name it <output label>. The CSR can be found in
            folder for <signing CA label>. From here on, the end entity
            key/certificate pair named <output label> will be referenced as
            <end entity label>. This name cannot change from this point
            forward.

    sign <end entity label> <signing CA label>
            Sign the CSR named <end entity label> with private key from
            <signing CA label> CA.

    genpkcs12 <end entity label> <signing CA label> [<export name>]
            Package private key and signed certificate from <end entity label>
            with CA certificate chain from <signing CA label> in a PKCS#12"
            bundle for export and optionally name it a more friendly name
            <export name>.

    revoke <end entity label> <signing CA label>
            Revoke issued certificate <end entity label> with CA <signing CA
            label> and automatically generate new CRL for <signing CA label>
            CA.

    import <export name>
            Take pkcs#12 file <export name> and extract the end entity
            certificate, private key, and all intermediate CAs and install to
            configured ssl directory. This automatically will run
            'update-ca-certificates' after to install the certificates.
EOF
    exit 1
}

##############################################################################
## Main
##############################################################################

main() {
    set -eo pipefail
    case "$1" in
        rootca)
            declare action="$2"
            rootca "$action"
            ;;
        subca)
            declare action="$2" subCaLabel="$3" signingCaLabel="$4"
            subca "$action" "$subCaLabel" "$signingCaLabel"
            ;;
        eecert)
            declare action="$2" requestLabel="$3" signingCaLabel="$4" outputLabel="$5"
            eecert "$action" "$requestLabel" "$signingCaLabel" "$outputLabel"
            ;;
        help)
            display_usage_main
            ;;
        *)
            echo "argument error: missing or incorrect subcommand."
            echo ""
            display_usage_main
            ;;
    esac
}

##############################################################################
## Runtime
##############################################################################
main "$@"
